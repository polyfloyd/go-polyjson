package polyjson

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

var codeTemplate = template.Must(template.New("codegen").Funcs(template.FuncMap{
	"lower": strings.ToLower,
}).Parse(
	`// Code generated by polyjson. DO NOT EDIT.

package {{ .Package }}

import (
	"bytes"
	"encoding/json"
	"fmt"
)
{{- range $type := .Types }}

// JSON marshaler implementations for {{ .Name }}.

{{- range .Variants }}

func (v {{ .Name }}) MarshalJSON() ([]byte, error) {
	type raw{{ .Name }} {{ .Name }}
	return json.Marshal(struct {
		raw{{ .Name }}
		Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
	}{raw{{ .Name }}: raw{{ .Name }}(v), Kind: "{{ .JSONName }}"})
}

var _ json.Marshaler = {{ .Name }}{}
{{- end  }}

func Unmarshal{{ .Name }}JSON(b []byte) ({{ .Name }}, error) {
	if len(b) == 0 || bytes.Equal(b, []byte("null")) {
		return nil, nil
	}

	var probe struct {
		Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
	}
	if err := json.Unmarshal(b, &probe); err != nil {
		return nil, fmt.Errorf("unmarshal {{ .Name }} {{ $type.Discriminant }}: %v", err)
	}

	switch probe.Kind {
{{- range .Variants }}
	case "{{ .JSONName }}":
		var v {{ .Name }}
		if err := json.Unmarshal(b, &v); err != nil {
			return nil, fmt.Errorf("unmarshal {{ .Name }}: %v", err)
		}
		return v, nil
{{- end }}
	default:
		return nil, fmt.Errorf("could not unmarshal {{ .Name }} JSON: unknown variant %q", probe.Kind)
	}
}
{{- end }}
{{ range $struct := .Structs }}
// JSON marshaler implementations for {{ .Name }} containing polymorphic fields.

func (v *{{ .Name }}) UnmarshalJSON(b []byte) error {
	type raw{{ .Name }} {{ .Name }}
	var data struct {
		raw{{ .Name }}
		{{- range .PolymorphicFields }}

		{{ if eq .Kind "Scalar" }}{{ .Name }} json.RawMessage
		{{- else if eq .Kind "Slice" }}{{ .Name }} []json.RawMessage
		{{- else if eq .Kind "Map" }}{{ .Name }} map[string]json.RawMessage
		{{- end }}
		{{- with .JSONName }}` + " `json:\"{{ . }}\"`" + `{{ end }}
		{{- end }}
	}
	if err := json.Unmarshal(b, &data); err != nil {
		return fmt.Errorf("unmarshal {{ $struct.Name }}: %v", err)
	}
{{ range .PolymorphicFields }}
	{{- if eq .Kind "Scalar" }}
	{{ lower .Name }}Field, err := Unmarshal{{ .Type }}JSON(data.{{ .Name }})
	if err != nil {
		return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}: %v", err)
	}
	{{- else if eq .Kind "Slice" }}
	{{ lower .Name }}Field := make([]{{ .Type }}, len(data.{{ .Name }}))
	for i, r := range data.{{ .Name }} {
		v, err := Unmarshal{{ .Type }}JSON(r)
		if err != nil {
			return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}[%d]: %v", i, err)
		}
		{{ lower .Name }}Field[i] = v
	}
	{{- else if eq .Kind "Map" }}
	{{ lower .Name }}Field := map[string]{{ .Type }}{}
	for k, r := range data.{{ .Name }} {
		v, err := Unmarshal{{ .Type }}JSON(r)
		if err != nil {
			return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}[%s]: %v", k, err)
		}
		{{ lower .Name }}Field[k] = v
	}
	{{- end }}
	{{- end }}

	*v = {{ .Name }}(data.raw{{ .Name }})
	{{- range .PolymorphicFields }}
	v.{{ .Name }} = {{ lower .Name }}Field
	{{- end }}
	return nil
}

var _ json.Unmarshaler = &{{ .Name }}{}
{{ end -}}
`))

func WriteMarshalerFile(filename, goPackage string, types []Type, structs []Struct) error {
	if goPackage == "" {
		return fmt.Errorf("a package name is required")
	}
	if len(types) == 0 {
		return fmt.Errorf("no types to generate marshaler for")
	}

	fd, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer fd.Close()

	err = codeTemplate.Execute(fd, struct {
		Package string
		Types   []Type
		Structs []Struct
	}{Package: goPackage, Types: types, Structs: structs})
	return err
}
