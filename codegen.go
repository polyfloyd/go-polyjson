package polyjson

import (
	"fmt"
	"os"
	"text/template"
)

var codeTemplate = template.Must(template.New("codegen").Parse(
	`// Code generated by polyjson. DO NOT EDIT.

package {{ .Package }}

import (
	"encoding/json"
	"fmt"
)

{{- range $type := .Types }}

// JSON marshaler implementations for {{ .Name }}.

{{- range .Variants }}

type rawjson{{ . }} {{ . }}

func (v {{ . }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(struct {
		rawjson{{ . }}
		Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
	}{rawjson{{ . }}: rawjson{{ . }}(v), Kind: "{{ . }}"})
}

var _ json.Marshaler = {{ . }}{}
{{- end  }}

func Unmarshal{{ .Name }}JSON(b []byte) ({{ .Name }}, error) {
	var probe struct {
		Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
	}
	if err := json.Unmarshal(b, &probe); err != nil {
		return nil, err
	}

	switch probe.Kind {
{{- range .Variants }}
	case "{{ . }}":
		var v {{ . }}
		if err := json.Unmarshal(b, &v); err != nil {
			return nil, err
		}
		return v, nil
{{- end }}
	default:
		return nil, fmt.Errorf("could not unmarshal {{ .Name }} JSON: unknown variant %q", probe.Kind)
	}
}
{{- end }}
`))

func WriteMarshalerFile(filename, goPackage string, types []Type) error {
	if goPackage == "" {
		return fmt.Errorf("a package name is required")
	}
	if len(types) == 0 {
		return fmt.Errorf("no types to generate marshaler for")
	}

	fd, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer fd.Close()

	err = codeTemplate.Execute(fd, struct {
		Package string
		Types   []Type
	}{Package: goPackage, Types: types})
	return err
}
